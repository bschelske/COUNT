# Plot formatting based off code by BG

import tkinter as tk
from tkinter import filedialog
import pandas as pd
import os
import re
from matplotlib import pyplot as plt
import numpy as np
from scipy.optimize import curve_fit


class DataSelectionApp:
    """UI for plotting files generated by main.py

    The first step is to convert the individual trial results into a plot friendly final_results.csv
    Each trial is assumed to be located within a folder (selected by user), these trials are parsed for DEP_response
    results.

    The sum of DEP_response TRUE and FALSE are calculated, then percentages are generated representing pDEP %.

    The aforementioned math is saved into final_results.csv, where indexes include filename and frequency

    This final_results.csv can be selected within the UI, and the values within will be plotted.
        *The exact plotting styles may need to be adjusted.
    """
    def __init__(self, master):
        """Initialize the UI"""
        self.master = master
        self.folder_path = tk.StringVar()  # Variable to store the selected folder path
        self.file_path = ""
        self.files = []  # Empty list that will accept an individual file, or files from a folder
        self.create_widgets()

    def create_widgets(self):
        """Create the UI style"""
        # Step 1, choose folder
        tk.Label(self.master, text="1. Convert trials into final_results.csv\n(likely choose the 'COUNT/results' folder)").grid(row=0, column=0, padx=5, pady=5)
        self.folder_button = tk.Button(self.master, text="Choose Folder", command=self.choose_trials_folder)
        self.folder_button.grid(row=0, column=2, padx=5, pady=5)

        # Step 2, choose final results selection button
        tk.Label(self.master, text="2. Choose the final_results.csv to plot").grid(row=3, column=0, padx=5, pady=5)
        self.file_button = tk.Button(self.master, text="Choose File", command=self.choose_final_results)
        self.file_button.grid(row=3, column=2, padx=5, pady=5)

        # Plot Multiple
        tk.Label(self.master, text="... or plot multiple from folder").grid(row=4, column=0, padx=5, pady=5)
        self.file_button = tk.Button(self.master, text="Choose Folder", command=self.plot_multiple)
        self.file_button.grid(row=4, column=2, padx=5, pady=5)

        # Quit button
        self.quit_button = tk.Button(self.master, text="        Quit        ", command=self.quit_ui)
        self.quit_button.grid(row=8, column=3, padx=1, pady=10)

    def choose_final_results(self):
        self.file_path = filedialog.askopenfilename()
        print("Selection:", self.file_path)
        self.confirm_selections()
        self.make_plot()

    def choose_trials_folder(self):
        self.folder_path.set(filedialog.askdirectory())  # Set the selected folder path
        print("Selection:", self.folder_path.get())
        self.confirm_selections()
        self.consolidate_trials()

    def plot_multiple(self):
        self.folder_path.set(filedialog.askdirectory())  # Set the selected folder path
        print("Selection:", self.folder_path.get())
        self.confirm_selections()
        self.make_plot()

    def input_handling(self):
        # Input handling
        if self.folder_path.get():
            self.files = [os.path.join(self.folder_path.get(), f) for f in os.listdir(self.folder_path.get()) if f.endswith('.csv')]
        if self.file_path:
            self.files = [self.file_path]
            print(f"Files:{self.file_path}")

    def confirm_selections(self):
        self.error_handling()
        self.input_handling()

    def consolidate_trials(self):
        """Converts individual trails into a results file.

        Prepares a csv file to plot later on. This function takes in the individual result files generated for each
        trial. For example, the files contained within the selected folder, '5khz_results.csv' through
        '100khz_results.csv' would be processed.

        The headers of these results files should be unchanged from how they were generated. The headers required
        include:
            'DEP_response'
            'frames_tracked'

        The number of TRUE and FALSE instances are summed, and percentages are calculated. These values are stored in
        the exported csv file, indexed by the filename and the extracted frequency from the filename (if possible)

        The frequency extraction will fail if get_frequency() fails.
        """
        results = []
        os.makedirs("results/final_results/", exist_ok=True)
        for file in self.files:
            df = pd.read_csv(file)
            filtered_df = df[df['frames_tracked'] != 1]
            count_DEP_True = (filtered_df['DEP_response'].astype(str).str.strip().str.upper() == 'TRUE').sum()
            count_DEP_False = (filtered_df['DEP_response'].astype(str).str.strip().str.upper() == 'FALSE').sum()
            result = {
                'filename': file,
                'frequency': get_frequency(file),
                'DEP_True': count_DEP_True,
                'DEP_False': count_DEP_False,
                'Percent True': (count_DEP_True / (count_DEP_True + count_DEP_False)),
            }
            results.append(result)
        results_df = pd.DataFrame(results)

        results_df.to_csv(f"results/final_results/final_results.csv")
        print("final_results.csv saved in COUNT/results folder. rename your file, so it isn't overwritten :)")

    def make_plot(self):
        """Plot pDEP rate (%) vs frequency from final results csv.

        The plotting styles are determined by this function. This function will break if you plot more than 3 files,
        to fix this, add more colors in the colors list. color codes can be found on matplotlib website

        When plotting multiple files, the legend will use filenames as labels.
        """
        # fig, ax = plt.subplots()
        for index, file in enumerate(self.files):
            label = os.path.basename(file)[:-4]  # Get filename excluding .csv
            print(label)
            colors = ['r', 'b', 'k']  # add more colors if necessary

            df = pd.read_csv(file)
            x = df['frequency']
            y = df['Percent True'] * 100

            # Fit the Gaussian function to the data
            popt, pcov = curve_fit(gaussian, x, y, p0=[1, np.mean(x), np.std(x)])
            plt.plot(x, gaussian(x, *popt), colors[index]+'-')  # label='Fitted Gaussian'
            # Plot the data
            plt.plot(x, y, label=label, color=colors[index], marker='o', linestyle='none')  # linestyle='dotted'

            # Plot the derivative
            # derivative = np.gradient(y, x)
            # plt.plot(derivative, label='derivative', marker='s', color='red',
            #          linestyle='dotted')

            df = None

        # # Define zooming in or fullscale
        y_limit = 100
        increment_size = 20

        # Customize axis labels
        plt.xlabel('Frequency (kHz)', fontsize=16, fontweight='bold')  # Change label as needed
        plt.ylabel('Percentage of pDEP cell (%)', fontsize=16, fontweight='bold')  # Change label as needed

        # Customize main/labelled axis ticks for x-axis
        plt.xticks(np.arange(0, 250, 50), fontsize=12)  # Adjust range and step as needed for x-axis
        plt.xlim(-5, 225)  # Adjust x-axis limits

        # Label every other tick starting from 0 for x-axis
        major_ticks_x = np.arange(0, 250, 50)
        minor_ticks_x = np.arange(25, 250, 50)
        plt.gca().set_xticks(major_ticks_x)
        plt.gca().set_xticks(minor_ticks_x, minor=True)
        plt.tick_params(axis='x', length=4, direction='in')

        # Customize main/labelled axis ticks for y-axis
        plt.yticks(np.arange(0, y_limit + 1, increment_size), fontsize=12)  # Adjust range and step as needed for y-axis
        plt.tick_params(axis='y', length=4, direction='in')
        plt.ylim(-5, y_limit + 1)  # Adjust y-axis limits to start a few pixels higher than the corner

        # Label every other tick starting from 0 for y-axis
        major_ticks_y = np.arange(0, y_limit + 1, increment_size)
        minor_ticks_y = np.arange(10, y_limit + 1, increment_size//2)
        plt.gca().set_yticks(major_ticks_y)
        plt.gca().set_yticks(minor_ticks_y, minor=True)

        # Adjust labelled tick length on the x-axis and y-axis
        plt.tick_params(axis='both', length=4, direction='in')  # Tick marks inside the plot

        # Customize axis thickness and remove top and right borders
        ax = plt.gca()
        ax.spines['bottom'].set_linewidth(2)  # Set x-axis thickness
        ax.spines['left'].set_linewidth(2)  # Set y-axis thickness
        ax.spines['top'].set_visible(False)  # Hide top border
        ax.spines['right'].set_visible(False)  # Hide right border

        # Place legend to the right side of the plot at the top
        if len(self.files) > 1:
            plt.legend(frameon=False, borderaxespad=0)  # Adjust location as needed

        plt.show()
        pass

    def error_handling(self):
        if self.file_path == '' and self.folder_path.get() == '':
            raise ValueError("No file selected!")
        if self.file_path and self.folder_path.get():
            raise ValueError(
                "file and folder selected?")

    def quit_ui(self):
        self.master.destroy()
        quit(2)


def get_frequency(string):
    """regex extraction of frequency from input string.

    If the final_results.csv includes unexpected frequencies, or "unexpected filename" this is the culprit.
    The assumption is that
        1. the nd2 file is tracked and turned into a "nd2filename_results.csv" file
        2. The "nd2filename_results.csv" contains a frequency followed by kHz

    Unexpected behavior might happen if
        there is no frequency in the filename
        if we stop using khz
        if we name the file with a number directly before the frequency.

        Example of bad filename (this case is handled)
        "a375 120 khz_results.csv" -> 375120 (caught when number is greater than 3 see pesky cell name if statement)
        Example of unexpected filename
        "exotic_cell_type2 15khz_results.csv" -> 215 (AAAAAAH!)

        The best practice would be to name files with "_numberkHz_" separated from other numbers


    """

    # Format string by removing whitespace and making it all lowercase
    formatted_string = string.replace(" ", "").lower()

    # Define regex pattern to match a number followed by an optional wildcard character and "khz"
    pattern = r"(\d+).?khz"

    # Search the string for the pattern
    match = re.search(pattern, formatted_string)

    if match:
        # Extract the number part from the match
        extracted_number = match.group(1)

        # Handle pesky cell names. Example: A375 140 khz would return 375140 otherwise
        if len(extracted_number) > 3:
            extracted_number = extracted_number[-3:]
    else:
        extracted_number = "unexpected filename"
        print("Could not find a number followed by 'khz' or 'kHz'")

    return extracted_number


def gaussian(x, amplitude, mean, stddev):
    return amplitude * np.exp(-((x - mean) / stddev) ** 2 / 2)


def create_plotting_ui():
    root = tk.Tk()
    root.iconbitmap(r'count.ico')
    root.title("COUNT Plotter")
    app = DataSelectionApp(root)
    root.mainloop()
    return app


def main():
    app = create_plotting_ui()


    # list = ['test 120_khz','95kHz8ampHICONC019_results', '25 kHz_7.2Vp-p', 'A375_7.2Vpp_10kHz001', 'A375 200kHz 5.8Vp-p_proof', '23Feb2024 Non RosetteSep 20kHz001']
    # for file in list:
    #     print(file, get_frequency(file))

if __name__ == "__main__":
    main()
